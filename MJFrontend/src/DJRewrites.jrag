aspect DJRewrites {

    public static String Program.DelphJRuntimeClass 	= "Reference";
    public static String Program.DelphJRuntimeIface 	= "IReference";
    public static String Program.DelphJRuntimePackage 	= "runtime";
    public static String Program.SubobjectModifier 	= "subobject";
    public static String Program.SelfParameterName 	= "self";
    public static String Program.InvokeMethodName 	= "invoke";
    public static String Program.GetDataMethodName	= "getData";


    // By not implementing stateful checking with some boolean we avoid
    // messing with iterative rewriting. In StaticFor.jrag many rewritings are
    // not changing the objects, they emit new ones so state is lost. 

    // TODO: The checks below will be refactored as inh attributes which are
    // more natural in JastAddJ.

    // Checks if wrapped for accesses
    syn boolean Access.isWrappedToReferenceOrNotNeeded() = type().isString();

    eq PrimitiveTypeAccess.isWrappedToReferenceOrNotNeeded() = true;

    eq ParTypeAccess.isWrappedToReferenceOrNotNeeded() {
	TypeAccess access = (TypeAccess) getTypeAccess();
	return access.getID().equals(Program.DelphJRuntimeClass) || 
	    access.getID().equals(Program.DelphJRuntimeIface);
    }

    // Checks if wrapped for declarations
    syn boolean ParameterDeclaration.isWrappedToReferenceOrNotNeeded() {
	Access access = getTypeAccess();
	return access.isWrappedToReferenceOrNotNeeded();
    }

    // Fine grained checks for various ASTNodes
    // TODO: Of course needs refactoring later

    syn boolean BodyDecl.canBeRewritten() = 
	!hostType().name().equals(Program.DelphJRuntimeClass) && 
	!hostType().name().equals(Program.DelphJRuntimeIface) && 
	hostType().compilationUnit().fromSource() &&
	!isAlreadyRewritten();

    syn boolean Expr.canBeRewritten() {
	if (!(!hostType().name().equals(Program.DelphJRuntimeClass) && 
	      !hostType().name().equals(Program.DelphJRuntimeIface) && 
	      hostType().compilationUnit().fromSource()))
	    return false;

	// If StringLiteral and ClassInstanceExpr are part of our system, we
	// don't rewrite them.
	if (getParent().getParent() instanceof MethodAccess) {
	    MethodAccess parentMethodAccess = (MethodAccess) getParent().getParent();

	    if (parentMethodAccess.getID().equals(Program.InvokeMethodName))
		return false;
	}

	return !isAlreadyRewritten();
    }

    syn boolean Stmt.canBeRewritten() = 	
	!hostType().name().equals(Program.DelphJRuntimeClass) && 
	!hostType().name().equals(Program.DelphJRuntimeIface) && 
	hostType().compilationUnit().fromSource() &&
	!isAlreadyRewritten();	

    eq MethodDecl.canBeRewritten() = super.canBeRewritten() && 
	!getID().equals("main");

    syn boolean BodyDecl.isAlreadyRewritten() = false;
    syn boolean Expr.isAlreadyRewritten() = false;
    syn boolean Stmt.isAlreadyRewritten() = false;

    eq MethodDecl.isAlreadyRewritten() {
	if(getNumParameter()>0)
	    return getParameter(0).getID().equals(Program.SelfParameterName);

	return !getTypeAccess().isWrappedToReferenceOrNotNeeded();
    }

    eq Dot.isAlreadyRewritten() = 
	isMethodAccess() && 
	((MethodAccess) lastAccess()).getID().equals(Program.GetDataMethodName);

    eq ClassInstanceExpr.isAlreadyRewritten() {
	Access access = getAccess();
	// Checks if this class instance expr is a parameterized reference
	// accesss of our runtime system.
	if (access instanceof ParTypeAccess && 
	    ((ParTypeAccess) access).isWrappedToReferenceOrNotNeeded())
	    return true;
	else {
	    // Else if this new is already a parameterized reference access
	    // enclosing.
	    ASTNode potentialEnclosingClassInstanceExpr = this.getParent().getParent();

	    if (potentialEnclosingClassInstanceExpr instanceof ClassInstanceExpr){
		ClassInstanceExpr enclosing = (ClassInstanceExpr) potentialEnclosingClassInstanceExpr;
		Access enclosingAccess = enclosing.getAccess();
		if (enclosingAccess instanceof ParTypeAccess)
		    return ((ParTypeAccess) enclosingAccess).isWrappedToReferenceOrNotNeeded();
	    }
	}

	return false;
    }

    eq FieldDeclaration.isAlreadyRewritten() = getTypeAccess().isWrappedToReferenceOrNotNeeded();
    eq VariableDeclaration.isAlreadyRewritten() = getTypeAccess().isWrappedToReferenceOrNotNeeded();

    rewrite FieldDeclaration { 
	when (canBeRewritten()) 
	    to FieldDeclaration {

	    // If field declaration contains initialization expression but not
	    // initialization expression with new. This will be dealt
	    // independently.
	    if (hasInit() && !(getInit() instanceof ClassInstanceExpr)) {
				
		List constructorList = new List();
		constructorList.add(getInit());
		constructorList.add(new NullLiteral("null"));
		ClassInstanceExpr classInstanceExpr = 
		    new ClassInstanceExpr(getTypeAccess().wrapToReference(), 
					  constructorList);
				
		this.setInit(classInstanceExpr);
	    }

	    this.setTypeAccess(getTypeAccess().wrapToReferenceIface());
			
	    // TODO: Needs refactoring, however is good enough for now, just
	    // to populate the subobject flag and enforce the side effect of
	    // removing the subobject modifier.
	    this.isSubobject = isSubobject();

	    return this;
	}
    }

    rewrite ClassInstanceExpr {
	when (canBeRewritten())
	    to ClassInstanceExpr {
	    List constructorList = new List();
	    constructorList.add(this);
	    constructorList.add(new NullLiteral("null"));
			
	    Access access = getAccess();

	    ClassInstanceExpr classInstanceExpr = new ClassInstanceExpr(
									access.wrapToReference(), 
									constructorList);

	    return classInstanceExpr;
	}
    }

    rewrite MethodDecl { 
	when (canBeRewritten())
	    to MethodDecl {

	    // Rewriting parameter list
	    List<ParameterDeclaration> newParameterList = new List<ParameterDeclaration>();
	    for (ParameterDeclaration pd : getParameters() ) {
		newParameterList.add(new ParameterDeclaration(pd.getTypeAccess().wrapToReferenceIface(),
							      pd.getID()));
	    }

	    // Add self parameter
	    TypeDecl type = hostType();
			
	    TypeAccess access = (TypeAccess) ((type instanceof GenericTypeDecl)?
					      ((GenericTypeDecl) type).createNoParamQualifiedAccess():type.createQualifiedAccess());
			
	    newParameterList.insertChild(new ParameterDeclaration(access.wrapToReferenceIface(),
								  Program.SelfParameterName), 0);

	    this.setParameterList(newParameterList);

	    // Rewrite return type
	    this.setTypeAccess(getTypeAccess().wrapToReferenceIface());
	    return this;
	}
    }

    rewrite Dot {
	
	// Rewrite method invocation to a method invocation with cast explicitely
	// applied to a method invocation on the self parameter as the receiver
	// that is passed as argument to the caller.
	when (!duringSyntacticClassification() && 
	      getLeft().isThisAccess() && 
	      isMethodAccess() && 
	      canBeRewritten() && 
	      leftSide().isVariable())
	    to CastExpr {

	    Expr dotAccess = getLeft();
			
	    MethodAccess oldMethodAccess = (MethodAccess) lastAccess();

	    MethodAccess newMethodAccess = new MethodAccess();

	    List<Expr> argumentList = new List<Expr>();

	    /********* 1. pass self as a string as first argument *********/
	    argumentList.add(new StringLiteral(oldMethodAccess.getID()));

	    /********* 2. pass class array as second argument *********/
	    ArrayInit arrayInitList = new ArrayInit();
			
	    // This determines if self parameter is present. Self parameter is
	    // present only/always inside a method declaration.
	    if (enclosingBodyDecl() instanceof MethodDecl) {
		// construct array of .class for method lookup
		arrayInitList.addInit(new Dot(new TypeAccess(Program.DelphJRuntimePackage, Program.DelphJRuntimeClass),
					      new ClassAccess()));
	    }
			
	    for (Expr arg : oldMethodAccess.getArgList()) {
		arrayInitList.addInit(new Dot(new TypeAccess(arg.type().packageName(), arg.type().getID()),
					      new ClassAccess()));
	    }

	    Opt<ArrayInit> classArrayInit = new Opt<ArrayInit>(arrayInitList);
	    ArrayCreationExpr classArrayCreationExpr = new ArrayCreationExpr(new ArrayTypeAccess(new TypeAccess("Class")), classArrayInit);

	    argumentList.add(classArrayCreationExpr);

	    /********* 3. pass object array as second argument *********/
	    ArrayInit objectInitList = new ArrayInit();
			
	    // This determines if self parameter is present. Self parameter is
	    // present only/always inside a method declaration
	    if (enclosingBodyDecl() instanceof MethodDecl) {
		// Construct array of actual instances.
		objectInitList.addInit(new VarAccess(Program.SelfParameterName));
	    }

	    // At the loop below all arguments that can be rewritten must be
	    // (should have been) rewritten.
	    for (Expr arg : oldMethodAccess.getArgList()) {
		objectInitList.addInit(arg);
	    }

	    Opt<ArrayInit> objectArrayInit = new Opt<ArrayInit>(objectInitList);
	    ArrayCreationExpr objectArrayCreationExpr = 
		new ArrayCreationExpr(new ArrayTypeAccess(new TypeAccess("Object")), objectArrayInit);

	    argumentList.add(objectArrayCreationExpr);

	    newMethodAccess.setArgList(argumentList);

	    // Set method name to invoke.
	    newMethodAccess.setID(Program.InvokeMethodName);
			
	    // Cast must be compatible with the return type of the rewritten
	    // method declaration.
	    return new CastExpr(oldMethodAccess.singleCandidateDecl().getTypeAccess().wrapToReferenceIface(),
				new Dot(new VarAccess(Program.SelfParameterName),
					newMethodAccess));
	}

	// Adding getData() method access in a two step approach. Add getData()
	// method, wire the new rewritten node and then cast the result.
	when(!duringSyntacticClassification() && 
	     isFieldAccess() && 
	     //!isThisAccess() &&
	     canBeRewritten() && 
	     isDest() && 
	     leftSide().isVariable())
	    to Access {
	    VarAccess var = (VarAccess) leftSide();

	    Access accessOfVar = var.type().createQualifiedAccess();

	    Expr nestedCastInParenthesis = var;

	    if (accessOfVar instanceof ParTypeAccess)
		accessOfVar = ((ParTypeAccess) accessOfVar).getTypeArgument(0);

	    ParExpr expr = null;
	    if (var.hasPrevExpr()) {
		Expr previousExpr = var.prevExpr(); // previousExpr := ((C)c.getData()) remaining := c1.b1

		ParExpr result = new ParExpr(new Dot(new Dot(previousExpr, var), 
						     new MethodAccess(Program.GetDataMethodName, new List<Expr>())));

		nestedCastInParenthesis = new ParExpr(new CastExpr(accessOfVar, result));

		this.parentDot().setLeft(nestedCastInParenthesis);

		if (rightSide().isVariable()) {

		    this.parentDot().setLeft(nestedCastInParenthesis);

		    return rightSide();
		}

		return rightSide();
	    } else {

		Dot dotExpression = new Dot(nestedCastInParenthesis, 
					    new MethodAccess(Program.GetDataMethodName, new List<Expr>()));

		expr = new ParExpr(new CastExpr(accessOfVar, dotExpression));

		this.setLeft(expr);

		return this;
	    }
	}
    }

    // VarAccesses that haven't been resolved during syntactic classification
    // are rewritten to VarAccesses if participating in Dot expressions.
    rewrite PackageAccess {
	when (!duringSyntacticClassification() && 
	      hasParentDot() && 
	      parentDot().hasParentDot() && 
	      parentDot().parentDot().leftSide() instanceof ParExpr)
	    to Access {
	    ParExpr parExpr = (ParExpr) parentDot().parentDot().leftSide();

	    TypeAccess accessToLookupInto = (TypeAccess) ((CastExpr) parExpr
							  .getExpr()).getTypeAccess();

	    if (accessToLookupInto.decl() instanceof ClassDecl) {
		FieldDeclaration foundField = ((ClassDecl) accessToLookupInto
					       .decl()).findSingleVariable(this.name());
		if (foundField != null)
		    return new VarAccess(getPackage(), start(), end());
	    }

	    return this;
	}
    }

    rewrite VariableDeclaration {
	when (canBeRewritten() && assignsSubobject())
	    to VariableDeclaration {

	    List<Expr> constructorList = new List<Expr>();
	    constructorList.add(getInit());
	    constructorList.add(new VarAccess(Program.SelfParameterName));

	    return new VariableDeclaration(
					   this.getModifiers(),
					   this.getTypeAccess().wrapToReferenceIface(),
					   this.getID(),
					   new Opt<Expr>(
							 new ClassInstanceExpr(
									       this.getTypeAccess().wrapToReference(), 
									       constructorList)));
	}
	when (canBeRewritten() && type().isReferenceType() && !type().isString())
	    to VariableDeclaration {
	    // We omit rewriting the initializing expression, it will get
	    // rewritten indipendently. 
	    return new VariableDeclaration(
					   this.getModifiers(),
					   this.getTypeAccess().wrapToReferenceIface(),
					   this.getID(),
					   new Opt<Expr>(getInit()));
	}
    }

    // Transforms a type access to a parameterized type access of Reference.
    // Integer -> Reference <Integer>
    syn Access Access.wrapToReference() {
	return new ParTypeAccess(new TypeAccess(Program.DelphJRuntimePackage, Program.DelphJRuntimeClass), 
				 new List().add(this));
    }

    syn Access Access.wrapToReferenceIface() {
	return new ParTypeAccess(new TypeAccess(Program.DelphJRuntimePackage, Program.DelphJRuntimeIface), 
				 new List().add(this));
    }

    // Overriding String type access.
    eq TypeAccess.wrapToReferenceIface() = name().equals("String")?this:super.wrapToReferenceIface();
    eq TypeAccess.wrapToReference() = name().equals("String")?this:super.wrapToReference();

    // No need for transformation of int, float, void, etc
    eq PrimitiveTypeAccess.wrapToReference() = this;
    eq PrimitiveTypeAccess.wrapToReferenceIface() = this;
}
